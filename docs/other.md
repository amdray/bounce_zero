в этой сессии мы работаем над фиксами кода, я указываю на проблему, далее твой ход - план работы такой - изучить то что я прислал в контексте приложения, далее в конектесте best practice C и emded устройств, далее в контексте pspsdk, документация лежит в папке "D:\OneDrive\VS Code Project\psp\pspsdk-master", далее сравнить с реализацией в "D:\OneDrive\VS Code Project\bounce_zero\original_code\java\com\nokia\mid\appl\boun" если это не графическая и не аудио часть, которая зависит от железа, далее предложить решение, объясняя это будет костыль или корректная архитекрурная правка, и далее я подтверждаю принимать правки или нет. договорились?



# нарушения

**тип нарушения:** тонкая логика / архитектурная хрупкость
**место нарушения:** файл `game.c` функция `deactivate_ring_pair`.
**описание нарушения:** "Магические числа" и жесткая привязка логики к ID тайлов (13, 14, 17, 18, 21 и т.д.). Если в будущем вы измените атлас (tileset) или порядок тайлов в редакторе, механика сбора колец и чекпоинтов сломается без ошибок компиляции. Логика "соседства" (изменение `x, y+1`) также жестко зашита в код.
**рекомендации к исправлению:** Рекомендуется использовать метаданные тайлов, которые уже упоминаются в коде (`tile_meta_db`). Вместо проверки конкретных ID, следует проверять свойства тайла (например, `is_collectible`) и хранить в метаданных ссылку на ID "неактивного" состояния этого же тайла.

---

**тип нарушения:** тонкая логика / избыточное копирование памяти
**место нарушения:** файл `graphics.c` функции `graphics_flush_batch` и `graphics_batch_sprite`.
**описание нарушения:** Двойная буферизация вершин в RAM. Сначала данные записываются в статический массив `s_batch.vertices`, а затем копируются через `memcpy` в память, выделенную через `sceGuGetMemory`. Это создает лишнюю нагрузку на CPU и шину памяти, которая является узким местом на PSP.
**рекомендации к исправлению:** Измените логику работы батча. Вместо накопления в промежуточном массиве, запрашивайте порцию памяти у GU в начале формирования батча (или при его переполнении) и записывайте данные вершин напрямую в адресное пространство, возвращаемое `sceGuGetMemory`.

---



---

**тип нарушения:** архитектурный просчет / "магические числа"
**место нарушения:** файл `physics.c` функции `testTile`, `thinCollide`, `edgeCollide`.
**описание нарушения:** Жесткая привязка логики к конкретным ID тайлов (например, `tileID >= 13 && tileID <= 24`, `tileID == 10`). Это прямое наследие ограничений J2ME, которое в C-коде превращается в трудноподдерживаемый «спагетти-код». Любое изменение в атласе тайлов потребует переписывания всей физики.
**рекомендации к исправлению:** Используйте систему флагов или свойств тайлов в метаданных (`TileMeta`). Физика должна проверять свойства (например, `is_lethal`, `is_bouncy`, `is_hoop`), а не конкретные номера картинок в атласе.
---


**тип нарушения:** архитектурный просчет / костыль
**место нарушения:** файл `tile_table.c` массив `TILE_DB`.
**описание нарушения:** Использование жестко заданного статического массива метаданных для всех игровых тайлов. Все свойства (индексы в атласе, трансформации, типы рендеринга) "зашиты" в код. Это делает невозможным изменение визуальной составляющей или добавление новых типов объектов без полной перекомпиляции проекта. Кроме того, наличие пустых ячеек (case 11, 12) указывает на хрупкую структуру, завязанную на порядковые индексы.
**рекомендации к исправлению:** Рекомендуется вынести описание метаданных тайлов во внешний конфигурационный файл (например, бинарный или текстовый), который будет загружаться динамически при инициализации уровня или игры.

---

**тип нарушения:** архитектурный просчет (God Object)
**место нарушения:** файл `types.h`, структура `Game`.
**описание нарушения:** Структура `Game` является классическим «антипаттерном» God Object. Она объединяет в себе абсолютно разнородные данные: системное состояние приложения (`state`), состояние пользовательского интерфейса (`menu_selection`, `instruction_part`), физическое состояние игрока (`player`), глобальную игровую статистику (`score`, `numLives`) и даже технические буферы ввода. Это создает сверхвысокую связность (coupling) — любой модуль, которому нужно просто изменить счет, получает доступ к управлению текстурами сплэш-экранов и навигации в меню.
**рекомендации к исправлению:** Рекомендуется разделить эту структуру на несколько независимых сущностей. Выделите `AppState` для системных флагов, `PlayerStats` для прогресса и `UIState` для навигации. Передавайте в функции только те части данных, которые им действительно необходимы для работы.

---

**тип нарушения:** велосипед / архитектурный просчет
**место нарушения:** файл `png.h` структура `sprite_rect_t`.
**описание нарушения:** Использование нормализованных UV-координат (от 0.0 до 1.0) в формате `float` для 2D-спрайтов. Хотя это стандарт для современных графических API, видеочип PSP (GU) работает эффективнее с прямыми пиксельными координатами. Текущий подход требует выполнения операций умножения `float * int` при каждой отрисовке каждого спрайта, что создает ненужную нагрузку на CPU без практической пользы, так как размеры атласов фиксированы.
**рекомендации к исправлению:** Рекомендуется хранить границы спрайтов в пиксельных координатах (используя типы `int` или `short`). Это позволит передавать данные в GU напрямую, избегая математических расчетов в "горячем" цикле рендеринга.


---

**тип нарушения:** архитектурный просчет (размытие ответственности)
**место нарушения:** файл `png.h` перечисление `png_transform_t`.
**описание нарушения:** Логика трансформации спрайтов (повороты, зеркалирование) вынесена в модуль загрузки изображений. Трансформация — это свойство процесса отрисовки и графического конвейера, а не формата файла или способа хранения данных в памяти.
**рекомендации к исправлению:** Перенесите перечисление трансформаций в заголовочный файл графической системы (`graphics.h`). Это позволит использовать его в других модулях без необходимости подключать библиотеку загрузки PNG.



то что выше оставим на потом

не существенно то что ниже:

---

**тип нарушения:** нерациональное использование ресурсов (VRAM)
**место нарушения:** файл `game.c` функция `game_init`.
**описание нарушения:** Загрузка сплэш-экранов (Nokia, Bounce) напрямую в VRAM (`png_load_texture_vram`). Видеопамять PSP крайне ограничена (всего 2 МБ). Хранить там статичные изображения, которые показываются один раз при запуске, — расточительство. Это может привести к тому, что для основных игровых текстур или двойной буферизации не хватит места в быстрой памяти.
**рекомендации к исправлению:** Загружайте одноразовые заставки в обычную оперативную память (RAM) и выгружайте их сразу после перехода в меню. В VRAM должны находиться только те ресурсы, которые используются в каждом кадре игрового процесса (тайлы, спрайты игрока).

---

**тип нарушения:** велосипед
**место нарушения:** файл `game.c` функция `game_render` (отрисовка большого мяча).
**описание нарушения:** Ручное создание "составного" спрайта 2x2 с вычислением трансформаций (`PNG_TRANSFORM_FLIP_X/Y`) в цикле для каждой четверти большого мяча. Это типичный подход для платформ, где нет аппаратного масштабирования. PSP поддерживает аппаратную трансформацию и масштабирование текстур "из коробки".
**рекомендации к исправлению:** Вместо ручной сборки из четырех кусков, используйте аппаратные возможности PSP GU для отрисовки одного спрайта с коэффициентом масштабирования (scaling) или просто добавьте в атлас готовую текстуру большого мяча.

---

**тип нарушения:** тонкая логика / дублирование
**место нарушения:** файл `game.c` функция `game_update` (обработка ввода).
**описание нарушения:** Смешивание логики событий (`buffered_left_pressed`) и состояний (`input_held`) в одном условии. Это создает ситуацию "двойного управления", где физика может среагировать дважды на одно нажатие или проигнорировать отпускание кнопки. Кроме того, это дублирует часть работы, которая уже должна быть инкапсулирована в `input.c`.
**рекомендации к исправлению:** Игровой цикл должен полагаться на чистые состояния "кнопка нажата в данном тике физики". Логика определения "была ли нажата кнопка с момента последнего тика" должна быть полностью скрыта внутри модуля `input`, возвращая `game.c` только конечный результат (флаг действия).

---

# нарушения

**тип нарушения:** критический архитектурный просчет / костыль
**место нарушения:** файл `graphics.c` функции `graphics_draw_number` и `graphics_draw_button_x`.
**описание нарушения:** Попиксельная отрисовка шрифта и иконки. Для каждого закрашенного пикселя вызывается `graphics_draw_rect`, которая внутри инициирует полноценный вызов отрисовки `sceGuDrawArray`. Для одного числа из 5 цифр это может породить тысячи вызовов отрисовки за кадр. На реальной PSP это приведет к катастрофическому падению FPS, так как GPU будет тратить всё время на обработку команд, а не на саму отрисовку.
**рекомендации к исправлению:** Перенесите шрифт 24-го размера и иконку кнопки в общую текстуру (атлас). Отрисовывайте символ или иконку целиком одним вызовом отрисовки как спрайт, а не по точкам.

---

**тип нарушения:** отход от нативного API / потенциальный баг
**место нарушения:** файл `graphics.c` функция `graphics_init`.
**описание нарушения:** Директивное указание адресов буферов кадра как `(void*)0` и `(void*)framebuffer_size`. Хотя это работает, это "магическое" распределение VRAM. Если в будущем вы добавите Z-буфер или дополнительные текстуры в VRAM, возникнет конфликт адресов, который трудно отладить. Также не учитывается, что адреса для `sceGuDrawBuffer` должны быть выровнены и часто указываются как относительные адреса внутри VRAM.
**рекомендации к исправлению:** Используйте более формализованный менеджер VRAM (например, через утилиту `vramalloc` или аналоги), чтобы динамически распределять адреса для Draw Buffer, Display Buffer и текстур. Это предотвратит наложение данных при усложнении графики.

---

**тип нарушения:** архитектурный просчет (State Machine)
**место нарушения:** файл `graphics.c` функции `graphics_begin_textured` и `graphics_begin_plain`.
**описание нарушения:** Принудительный сброс батча (`graphics_flush_batch`) внутри функций смены режима. Если игровой код часто переключается между текстурами и примитивами (как было замечено в `game.c`), это сводит на нет всю эффективность батчинга, превращая его в серию одиночных вызовов.
**рекомендации к исправлению:** Оптимизируйте вызовы в игровом цикле так, чтобы сначала отрисовывались все текстурированные объекты, а затем все примитивы. В самих функциях `graphics.c` добавьте проверку: если нужный режим уже активен, не делайте лишних системных вызовов `sceGuEnable/Disable`.

---

**тип нарушения:** архитектурный просчет / велосипед
**место нарушения:** файл `png.c` функция `getStaticVramBuffer`.
**описание нарушения:** Реализован простейший «стековый» или «bump» аллокатор видеопамяти, который только увеличивает смещение (`staticVramOffset`). В коде полностью отсутствует механизм освобождения или повторного использования участков VRAM.
**рекомендации к исправлению:** Рекомендуется реализовать более полноценный менеджер VRAM (например, на основе списков свободных блоков) или использовать готовые библиотеки для аллокации (например, `vramalloc`). В текущем виде приложение неизбежно исчерпает видеопамять при любой перезагрузке уровня или частой смене текстур.


---

**тип нарушения:** ошибка в коде / утечка памяти
**место нарушения:** файл `png.c` функция `png_free_texture`.
**описание нарушения:** При удалении текстуры, находящейся в VRAM, функция освобождает только саму управляющую структуру `texture_t`, но никак не помечает область в видеопамяти как свободную (из-за отсутствия менеджера памяти, описанного выше). Это делает невозможным циклическую загрузку ресурсов.
**рекомендации к исправлению:** Необходимо связать систему освобождения памяти с аллокатором VRAM. Если используется простейший указатель, то освобождение возможно только в порядке, обратном загрузке (LIFO), либо требуется полная очистка VRAM при смене игровых состояний.

---

**тип нарушения:** архитектурный просчет (performance killer)
**место нарушения:** файл `png.c` функция `png_draw_sprite_uv4`.
**описание нарушения:** Функция принудительно вызывает `graphics_flush_batch()` перед каждой отрисовкой. Так как эта функция используется через `png_draw_sprite_transform` для рендеринга больших объектов (например, большого мяча, состоящего из 4 частей), батчинг полностью ломается. Вместо того чтобы отрисовать 4 спрайта одним вызовом, видеочип получает 4 отдельных команды отрисовки с переключением контекста между ними.
**рекомендации к исправлению:** Следует расширить систему батчинга так, чтобы она поддерживала произвольные UV-координаты для вершин в рамках одного типа примитива (`GU_SPRITES` или `GU_TRIANGLES`), либо вынести `flush` на уровень выше, вызывая его только при реальной необходимости смены текстуры или режима блендинга.

---

**тип нарушения:** отход от нативного API / тонкая логика
**место нарушения:** файл `png.c` переменная `staticVramOffset`.
**описание нарушения:** Начальное смещение для аллокатора VRAM жестко задано как двойной размер фреймбуфера. Это не учитывает возможного использования Z-буфера (глубины), который может потребоваться даже в 2D (например, для сложной сортировки слоев), а также не учитывает особенности выравнивания адресов для различных режимов дисплея.
**рекомендации к исправлению:** Начальный адрес свободной VRAM должен вычисляться динамически на основе параметров, переданных в `sceGuDrawBuffer` и `sceGuDispBuffer`, учитывая фактическое наличие и размер буфера глубины.


---

**тип нарушения:** отход от нативного API / "велосипед" (в контексте UX)
**место нарушения:** файл `input.c` функция `input_init`.
**описание нарушения:** Принудительная установка `PSP_CTRL_MODE_DIGITAL`. На PSP это отключает опрос аналогового стика. Несмотря на то, что оригинальный Bounce — игра под кнопочные телефоны, для PSP-сообщества считается "хорошим тоном" дублировать действия крестовины на аналоговый стик. В текущем режиме стик полностью мертв, и его нельзя использовать даже для навигации в меню.
**рекомендации к исправлению:** Переключитесь на `PSP_CTRL_MODE_ANALOG`. В функциях проверки движения добавьте проверку отклонения стика (например, если значение по оси X больше 128 + порог чувствительности). Это сделает управление более современным и удобным для консоли.

---

# нарушения

**тип нарушения:** архитектурный просчет (performance bottleneck)
**место нарушения:** файл `level.c` функция `render_moving_spikes_tile`.
**описание нарушения:** Внутри функции рендеринга тайла вызывается `level_find_moving_object_at`, которая выполняет цикл по всем движущимся объектам уровня. Поскольку этот вызов происходит для каждого видимого тайла шипов в каждом кадре, сложность отрисовки растет пропорционально количеству объектов и площади их покрытия. На PSP это приведет к заметным "просадкам" кадров на уровнях с большим количеством ловушек.
**рекомендации к исправлению:** Рекомендуется изменить подход: вместо поиска объекта для тайла, нужно итерироваться по списку активных движущихся объектов один раз за кадр и отрисовывать их поверх карты, либо кэшировать указатель на объект прямо в сетке тайлов при загрузке уровня.

---

**тип нарушения:** архитектурный просчет (статический лимит)
**место нарушения:** файл `level.c` функция `hoop_fg_push`.
**описание нарушения:** Использование фиксированного массива `s_hoop_fg` с лимитом `RING_FG_QUEUE_MAX`. Если на одном экране окажется больше колец, чем размер очереди (например, в плотном бонусном уровне), часть колец просто перестанет отрисовываться (точнее, их передний план). Это создает визуальный баг "шар поверх кольца".
**рекомендации к исправлению:** Поскольку кольца всегда привязаны к тайлам, эффективнее добавить в структуру `TileMeta` или в саму карту флаг необходимости отрисовки переднего плана. Тогда вторым проходом рендеринга можно будет просто отрисовать нужные части колец, не используя промежуточную очередь.

---

**тип нарушения:** тонкая логика / костыль
**место нарушения:** файл `level.c` функция `render_hoop_tile`.
**описание нарушения:** Жестко зашитые (hardcoded) трансформации для разных типов колец прямо в коде функции. Это делает невозможным использование колец под другими углами (например, диагональных) без дописывания кода в этом модуле. Логика "если ID от 13 до 28" дублирует информацию, которая должна быть в метаданных.
**рекомендации к исправлению:** Перенесите параметры трансформации фона и переднего плана в таблицу `TileMeta`. Функция рендеринга должна просто брать готовое значение `transform` из таблицы, не зная, какой именно ID тайла она сейчас рисует.

---

**тип нарушения:** велосипед / архитектурный просчет
**место нарушения:** файл `sound.c` функция `ott_audio_callback`.
**описание нарушения:** Ручное смешивание (микширование) трех аудио-потоков в одном callback-канале. PSP имеет аппаратную поддержку нескольких аудио-каналов (до 8 штук), которые микшируются системным софт-процессором или железом. Создание собственного микшера внутри callback — это лишняя трата ресурсов CPU Allegrex, которые могли бы пойти на игровую логику или графику.
**рекомендации к исправлению:** Рекомендуется использовать `pspaudiolib` для открытия трех независимых каналов (по одному на каждый тип звука). Это упростит код: каждый канал будет иметь свой callback только для одного осциллятора, а системная библиотека сама выполнит смешивание.

---

**тип нарушения:** архитектурный просчет (performance killer)
**место нарушения:** файл `sound.c` функции `ott_audio_callback` и `generate_player_sample`.
**описание нарушения:** Использование вычислений с плавающей точкой (`float`) внутри критического цикла аудио-обработки. Процессор PSP (MIPS 4KE) имеет FPU, но операции с плавающей точкой всё равно медленнее целочисленных. Особенно критично использование `1.0f / (float)PSP_SR` и постоянные преобразования типов внутри цикла, который выполняется 44100 раз в секунду для каждого канала.
**рекомендации к исправлению:** Полностью переведите внутренний цикл генерации звука на целочисленную арифметику с фиксированной запятой (fixed-point). Предвычисляйте все константы времени (`sample_length`) заранее.

---

**тип нарушения:** тонкая логика (race condition)
**место нарушения:** файл `sound.c` функция `ott_player_start`.
**описание нарушения:** Использование `sceKernelCpuSuspendIntr()` для обеспечения атомарности запуска звука. Это слишком "тяжелый" метод для синхронизации с аудио-потоком. Приостановка всех прерываний системы ради установки нескольких переменных в плеере может негативно сказаться на других системных процессах (например, на работе Wi-Fi или I/O).
**рекомендации к исправлению:** Для синхронизации аудио-коллбэка и основного потока лучше использовать флаг "занятости" или простые атомарные операции. Поскольку данные только пишутся в основном потоке и только читаются в аудио-потоке, достаточно правильно выставить флаг `is_playing` в самом конце после инициализации всех параметров ноты.

---

**тип нарушения:** архитектурный просчет
**место нарушения:** файл `sound.c` функция `sound_init`.
**описание нарушения:** Жесткая привязка трех конкретных звуковых эффектов к глобальным переменным внутри модуля. Это мешает расширяемости (например, если вы захотите добавить фоновую музыку или четвертый звук).
**рекомендации к исправлению:** Создайте массив структур `ott_player_t` или систему динамической регистрации звуков. Это позволит загружать любое количество эффектов без изменения кода функций `sound_init` и `ott_audio_callback`.

---

**тип нарушения:** тонкая логика / риск переполнения
**место нарушения:** файл `local.c` функция `local_get_text_with_params`.
**описание нарушения:** Использование `static char` буферов для возврата результата. Это делает функцию не реентерабельной. Если вызвать её дважды в одном выражении (например, в аргументах `printf` или при отрисовке двух разных строк в одном кадре), второй вызов перезапишет данные первого. Также размер `MAX_STRING_LENGTH` (1024) может быть недостаточен для длинных инструкций с несколькими подставленными параметрами.
**рекомендации к исправлению:** Либо передавайте буфер для результата из вызывающей функции (caller-owned buffer), либо используйте динамическое выделение памяти, если время жизни строки должно быть долгим.

---

---

**тип нарушения:** костыль / отход от нативного API
**место нарушения:** файл `local.c` функция `detect_phone_language`.
**описание нарушения:** Ручное сопоставление кодов языков PSP с внутренними строковыми идентификаторами (`ru-RU`, `de`, `xx`). Это «зашивает» поддержку языков в код.
**рекомендации к исправлению:** Рекомендуется использовать системные коды `PSP_SYSTEMPARAM_LANGUAGE_*` напрямую как часть имени файла (например, `lang/lang.11` для русского) или создать таблицу соответствия во внешнем файле, чтобы добавление нового перевода не требовало изменения кода модуля.

---

**тип нарушения:** костыль / дублирование
**место нарушения:** файл `local.c` функции `local_text_select_level` и `local_text_settings`.
**описание нарушения:** Хардкод строк «Выбор уровня» и «Настройки» прямо в C-файле. Это нарушает саму концепцию интернационализации (i18n), ради которой создан этот модуль. Часть строк берется из файлов, а часть — из условий `strncmp` в коде.
**рекомендации к исправлению:** Перенесите все строковые ресурсы в файлы `lang.*`. Если строка отсутствует в оригинальном наборе Bounce, добавьте её в конец файла, расширив `MAX_STRING_ID`.

---

**тип нарушения:** велосипед (эмуляция фиксированной запятой)
**место нарушения:** файл `types.h`, структура `Player`.
**описание нарушения:** Использование обычных `int` для координат (`xPos`, `yPos`) и скоростей с логикой «x0.1 пикселя/кадр» является попыткой вручную реализовать арифметику с фиксированной запятой (fixed-point). Для процессора MIPS (PSP) стандартом является использование битовых сдвигов (например, формат 24.8). Текущий подход с делением на `MOVEMENT_STEP_DIVISOR` (10) работает значительно медленнее побитовых операций и вносит погрешности при расчетах векторов.
**рекомендации к исправлению:** Перейдите на стандартную арифметику с фиксированной запятой, где дробная часть занимает фиксированное количество бит (например, 8 бит). Это позволит использовать быстрые побитовые сдвиги вместо деления и обеспечит более высокую точность физических расчетов.

---

**тип нарушения:** архитектурный просчет (глобальное состояние)
**место нарушения:** файл `types.h`, объявление `extern Game g_game;`.
**описание нарушения:** Использование глобальной переменной для доступа ко всем данным игры провоцирует написание кода с побочными эффектами (side effects). Это крайне затрудняет отладку и тестирование, так как любая функция в любом модуле может непредсказуемо изменить состояние игрока или сбросить выбор в меню, не заявляя об этом в своих аргументах.
**рекомендации к исправлению:** Избавьтесь от `extern` объявления в общем заголовочном файле. Передавайте указатели на конкретные структуры данных в функции в качестве аргументов. Это сделает зависимости между модулями явными и прозрачными.

---

**тип нарушения:** тонкая логика (жесткие ограничения контента)
**место нарушения:** файл `types.h`, макрос `MAX_LEVEL 11`.
**описание нарушения:** Жестко заданное максимальное количество уровней на уровне препроцессора. Это ограничивает расширяемость игры: добавление 12-го уровня потребует перекомпиляции всех модулей, включающих этот заголовок. Также это принуждает UI-код (меню) полагаться на константу вместо реального наличия файлов на диске.
**рекомендации к исправлению:** Определяйте количество уровней динамически при запуске приложения (например, путем сканирования директории с уровнями) или вынесите это значение в загружаемый конфигурационный файл.

---

**тип нарушения:** архитектурный просчет / смешивание уровней абстракции
**место нарушения:** файл `graphics.h` функции `graphics_draw_number`, `graphics_draw_button_x`, `utf8_decode_to_codepoint`.
**описание нарушения:** Заголовочный файл базовой графической системы содержит функции для отрисовки специфических игровых элементов (кнопки контроллера PSP, числа через конкретный шрифт) и утилиту декодирования текста. Это нарушает принцип единственной ответственности: графическое ядро не должно знать о деталях игрового интерфейса или кодировках строк.
**рекомендации к исправлению:** Вынесите логику декодирования строк в отдельный вспомогательный модуль. Функции отрисовки элементов интерфейса (кнопки, специфические шрифты) перенесите в специализированный модуль UI, оставив в графическом ядре только универсальные примитивы.

--- 

**тип нарушения:** костыль (принудительное управление состоянием)
**место нарушения:** файл `graphics.h` функции `graphics_begin_plain`, `graphics_begin_textured`.
**описание нарушения:** Перекладывание ответственности за управление состоянием текстурирования на вызывающий код через «Протокол использования». Это создает хрупкую архитектуру, где пропуск одного системного вызова в игровом цикле приводит к визуальным артефактам, которые сложно отследить в больших проектах.
**рекомендации к исправлению:** Реализуйте автоматическое управление состоянием внутри функций отрисовки. Каждая функция должна самостоятельно проверять текущий статус текстурирования и изменять его только при необходимости, используя внутреннее кэширование состояния в модуле графики.

---

**тип нарушения:** архитектурный просчет
**место нарушения:** файл `png.h` структура `texture_t`.
**описание нарушения:** Модуль, названный в честь формата файлов (PNG), содержит базовое определение текстуры для всей игры. Это создает жесткую привязку: если в будущем возникнет необходимость использовать нативные для PSP форматы (например, GIM) или сжатые текстуры (PVR/ETC), придется либо хранить их в структуре "png_t", либо переписывать все вызовы отрисовки во всем проекте.
**рекомендации к исправлению:** Рекомендуется переименовать модуль и структуры в более абстрактные (например, `texture.h` и `Texture`), отделив логику загрузки конкретного формата (PNG) от логики хранения и использования графических ресурсов.

---

**тип нарушения:** God Object (Божественный объект)
**место нарушения:** файл `types.h` структура `Game`, файл `main.c` переменная `g_game`.
**описание нарушения:** Структура `Game` нарушает принцип разделения ответственности на фундаментальном уровне. Она объединяет системное состояние (текущий экран), игровую статистику (очки, жизни), физические данные игрока и технические буферы ввода. В результате почти каждый модуль в проекте (`physics`, `menu`, `level`, `save`) вынужден подключать `types.h` и работать с одной и той же глобальной переменной. Это делает систему крайне хрупкой: изменение в логике меню может случайно затронуть физику мяча или процесс сохранения.
**рекомендации к исправлению:** Расслоите структуру на независимые контексты: `SessionStats` (счет, уровни), `PlayerState` (физика), `EngineState` (системные флаги). Модули должны получать только свой контекст.



















### 1. Пиксель-перфект integer scaling (Zoom)

**Сложность: Средняя**

Реализация масштабирования (например, 2x) потребует изменений в нескольких модулях, так как текущий код завязан на фиксированные размеры экрана PSP (480x272).

- Изменения в рендеринге: Вам придется модифицировать функции отрисовки в graphics.c и png.c. Поскольку вы используете GU_TRANSFORM_2D, координаты и размеры спрайтов в функциях png_draw_sprite и graphics_draw_rect нужно будет умножать на коэффициент зума.
- Логика камеры: В level.c функция level_render_visible_area рассчитывает количество видимых тайлов исходя из screenWidth и screenHeight. При включении зума видимая область уровня уменьшится, поэтому параметры startTile и endTile должны пересчитываться с учетом масштаба.
- Интерфейс (HUD): Масштабирование шрифтов в graphics_draw_text сложнее, так как они отрисовываются посимвольно из атласа. Вам потребуется масштабировать каждый прямоугольник (rect) символа при выводе.
- Рекомендация: Проще всего реализовать это через глобальный коэффициент масштаба, который будет применяться во всех функциях graphics_draw_* и png_draw_*.

### 2. Пересчет физики с 30 до 60 кадров

**Сложность: Высокая (из-за рисков нарушения аутентичности)**

Простое изменение констант может сломать «чувство» игры, так как физика Bounce сильно завязана на целочисленные вычисления и фиксированный шаг.

- Изменение тайминга: В main.c нужно изменить PHYSICS_DT_MS с 30 на 15 или 16.
- Масштабирование констант: Если физика будет вызываться в 2 раза чаще, вам теоретически нужно уменьшить вдвое все значения ускорения (HORZ_ACCELL, GRAVITY_ACCELL) и силы прыжка (JUMP_STRENGTH) в types.h.
- Проблема округления: Многие константы в types.h — нечетные или маленькие (например, NORMAL_GRAVITY_ACCELL 4, FRICTION_DECELL 4). Если после деления на 2 вы получите нецелое число, а код продолжит использовать int, мяч начнет двигаться иначе: он может не допрыгивать до платформ или иметь другую инерцию.
- MOVEMENT_STEP_DIVISOR: Физика в physics.c использует пошаговое перемещение, деля скорость на 10 (MOVEMENT_STEP_DIVISOR). Это ядро оригинальной механики. Переход на 60 FPS потребует глубокого тестирования того, как эти «микро-шаги» суммируются в коллизиях.
- Рекомендация: Вместо изменения констант физики, лучше оставить её работать на 30 Гц, но внедрить интерполяцию координат при рендеринге в game_render. Это даст визуальную плавность 60 FPS без риска сломать логику столкновений.

### Итог

- Зум: Добавить относительно легко, если централизованно внедрить множитель координат в graphics.c.
- 60 FPS Физика: Очень рискованно. Математика в physics.c слишком специфична. Лучше использовать графическую интерполяцию, сохраняя логический тик 30 мс.

---

Портирование приложения на **vitasdk** для PS Vita является задачей средней сложности. Основной объем работы связан с заменой системных API и графического конвейера, в то время как логика и физика на языке C переносятся практически без изменений.

## Технический анализ портирования

---

### 1. Графическая подсистема (Наибольшая сложность)

Графический чип PSP работает с фиксированным конвейером (`GU`), в то время как PS Vita использует программируемый конвейер (`GXM`).

- Отрисовка: Прямые вызовы sceGu... из graphics.c и png.c несовместимы с Vita. Портирование потребует либо написания шейдеров на языке CG, либо использования оберток, таких как libvita2d, которая предоставляет функции, аналогичные вашим (vita2d_draw_rectangle, vita2d_draw_texture).
- Разрешение: Экран Vita имеет разрешение 960x544, что ровно в 2 раза больше PSP (480x272). Это делает реализацию "пиксель-перфект зума" тривиальной, так как один пиксель PSP идеально ложится в сетку 2x2 или 4x4 пикселя Vita без артефактов интерполяции.

### 2. Ввод и системные API

- Константы: Имена кнопок и функций меняются (например, префикс PSP_CTRL_ меняется на SCE_CTRL_, а sceCtrlReadLatch заменяется на sceCtrlPeekBufferPositive).
- Потоки: Система колбэков выхода (Exit Callback) на Vita реализована иначе, чем на PSP, и требует использования системных событий sceAppMgr.

### 3. Звук и файловая система

- Аудио: API звука на Vita (SceAudioOut) отличается от pspaudiolib. Синтезатор OTT в sound.c останется прежним, но функцию заполнения буфера (callback) нужно будет адаптировать под формат Vita.
- Пути: Пути ms0:/ или ./ должны быть заменены на системные разделы Vita, такие как ux0:data/ВашеПриложение/.

### 4. Физика и логика (Низкая сложность)

- Модули physics.c, level.c, local.c и tile_table.c написаны на стандартном C и не используют специфичных для PSP вызовов. Они переносятся путем простой перекомпиляции под архитектуру ARM (vitasdk использует arm-vita-eabi-gcc).

---

### Сводная таблица изменений

| Модуль | Уровень сложности | Основная задача |
| --- | --- | --- |
| graphics.c | Высокий | Замена GU на GXM или vita2d |
| input.c | Низкий | Смена констант PSP_ на SCE_ |
| sound.c | Средний | Адаптация callback под SceAudioOut |
| physics.c | Нулевой | Только перекомпиляция |
| save.c | Низкий | Смена путей к файлам на ux0: |

---

Портирование вашего приложения на **Nintendo 3DS (devkitARM / libctru)** по сложности сопоставимо с портом на PS Vita, но имеет свои уникальные архитектурные нюансы, связанные с аппаратным обеспечением и двойным экраном.

---

# Анализ портирования на Nintendo 3DS

**Сложность: Средняя**

### 1. Графическая система (PICA200 и Citro2D)

3DS использует графический чип PICA200, который сильно отличается от PSP GU.

- API: Вместо pspgu вам придется использовать citro3d (низкоуровневый) или, что более логично для вашего проекта, citro2d. Последний по духу очень близок к вашему graphics.c: он также работает с батчингом спрайтов и атласами.
- Разрешение: Это главный «подводный камень». Разрешение верхнего экрана 3DS — 400x240 (против 480x272 у PSP). Ваш код в level.c и menu.c жестко завязан на ширину 480. При переносе часть игрового поля будет обрезана, либо потребуется пересчет логики видимой области (level_render_visible_area).
- Текстуры: 3DS требует, чтобы текстуры в памяти были «тайлированными» (tiled format). Вы не сможете просто скопировать массив пикселей из stb_image в VRAM, как вы делали в png.c. Потребуется использовать утилиты типа tex3ds или программную конвертацию.

### 2. Двухэкранная архитектура

Текущий код (`main.c` и `game_render`) рассчитан на один экран.

- Разделение ответственности: На 3DS хорошим тоном считается вынос HUD (счет, жизни) на нижний экран (320x240). Это потребует разделения функции game_render на две части и изменения структуры Game для управления состояниями обоих экранов.

### 3. Звук (NDSP)

- Аудио-движок: В sound.c используется callback-система PSP. На 3DS библиотека libctru использует сервис ndsp. Вам придется переписать систему подачи сэмплов: вместо прямого заполнения буфера в прерывании, нужно будет организовать циклическую очередь буферов (wave buffers). Логика синтеза OTT перенесется без изменений.

### 4. Ввод и управление

- HID: Модуль input.c потребует минимальных правок. sceCtrlReadBufferPositive заменяется на hidKeysDown() и hidKeysHeld().
- Аналоговое управление: В отличие от PSP, Circle Pad на 3DS очень надежен. Будет крайне просто добавить поддержку плавного движения мяча.

---

### Вердикт по модулям

| Модуль | Статус при портировании |
| --- | --- |
| physics.c | Полная совместимость. ARM11 процессор 3DS легко справится с попиксельными коллизиями. |
| level.c | Требует доработки. Необходим пересчет координат под экран 400x240. |
| graphics.c | Полная замена. Весь код на pspgu должен быть переписан на citro2d. |
| local.c | Полная совместимость. |
| save.c | Минимальные правки. Изменение путей к файлам на sdmc:/. |

---

### Итоговое сравнение сложности

Если сравнивать с PS Vita:

1. На Vita проще сделать «красиво» из-за огромного разрешения и мощного GPU.
2. На 3DS проще сохранить «ретро-дух» игры, но сложнее адаптировать интерфейс из-за более узкого экрана и необходимости работы с двумя дисплеями.

В целом, ваш C-код достаточно чист для того, чтобы опытный разработчик перенес его на 3DS за 1–2 недели.

---


















---

**тип нарушения:** Инверсия ответственности (Logic Leaking)
**место нарушения:** файл `menu.c` функции инициализации уровня.
**описание нарушения:** Модуль меню берет на себя несвойственные ему задачи управления жизненным циклом игры. Именно в коде меню прописано, какие параметры игрока нужно сбросить при старте уровня (`numLives`, `score`, `player_init`). Если вы захотите добавить другой способ запуска уровня (например, через дебаг-консоль или авто-переход), вам придется дублировать эту логику инициализации или вызывать функции меню из ядра игры.
**рекомендации к исправлению:** Перенесите логику управления игровым сеансом в модуль `game.c`. Меню должно лишь посылать высокоуровневую команду «начать игру с уровня X», а вся подготовка данных должна происходить внутри игрового ядра.

---

**тип нарушения:** Загрязнение абстракции (Abstaction Pollution)
**место нарушения:** файл `graphics.c` функции `graphics_draw_button_x` и `graphics_draw_number`.
**описание нарушения:** Модуль, который должен отвечать за низкоуровневый вывод примитивов на экран PSP, «знает» о специфических элементах игрового интерфейса. Наличие кода для отрисовки конкретной кнопки контроллера или специфического формата игровых чисел внутри графического ядра привязывает графическую библиотеку к конкретной игре. Это мешает повторному использованию графического модуля в других проектах и перегружает его деталями, которые должны находиться на уровне UI.
**рекомендации к исправлению:** Оставьте в `graphics.c` только универсальные функции (спрайты, текст, линии). Отрисовку иконок кнопок и форматирование чисел перенесите в `menu.c` или новый модуль `ui.c`.

---

**тип нарушения:** Отсутствие инкапсуляции ввода
**место нарушения:** файл `main.c` (обработка событий) и `types.h` (поля `buffered_...`).
**описание нарушения:** Модуль `input.c` фактически не выполняет свою работу до конца. Он лишь транслирует нажатия кнопок, а логика «запоминания» нажатия до следующего тика физики вынесена в главный цикл `main.c` и общую структуру `Game`. Это означает, что любое изменение в способе опроса ввода (например, добавление поддержки аналогового стика или сетевого ввода) потребует правок в логическом ядре и главном цикле.
**рекомендации к исправлению:** Инкапсулируйте всю логику буферизации и «событий» внутри `input.c`. Основной цикл должен запрашивать у модуля ввода факт совершения действия (например, `input_did_jump()`), не заботясь о том, как и где это событие хранилось.

---

**тип нарушения:** Смешивание логики и визуализации (Render-Logic Coupling)
**место нарушения:** файл `level.c` функция `level_render_visible_area`.
**описание нарушения:** Внутри функций отрисовки уровня происходят вызовы, ищущие игровые объекты в памяти (`level_find_moving_object_at`). Это означает, что процесс отображения мира напрямую зависит от структуры хранения объектов в памяти. В идеальной архитектуре рендеринг должен получать готовый список объектов для отрисовки, а не искать их самостоятельно во время прохода по тайлам.
**рекомендации к исправлению:** Разделите обход уровня на два этапа: обновление состояний (логика) и сбор данных для отрисовки. Рендерер должен быть максимально «глупым» и просто рисовать то, что ему передали.

Эти нарушения — основная причина того, почему код выглядит как порт с Java, а не как нативное C-приложение. Исправление этих четырех узлов сделает проект значительно чище и упростит его расширение.

---

Если вы внедрите предложенные архитектурные правки, ваш код действительно может превратиться в **универсальный 2D-движок** для портирования классических платформеров. Однако для поддержки особенностей *Bounce Back* (анимации, другой размер тайлов) потребуется перейти от «жесткого кодирования» к **системе данных**.

Ниже приведен анализ того, что именно нужно изменить в архитектуре, чтобы она стала по-настоящему гибкой.

---

### 1. Отказ от константного размера тайла

В текущем коде `TILE_SIZE` жестко зашит в физику и маски коллизий. Для универсальности:

- Динамические маски: Вам придется либо хранить маски в самих файлах уровней/ресурсов, либо загружать разные наборы .inc файлов в зависимости от игры.
- Переменная tile_size: Все расчеты в level.c (отрисовка) и physics.c (коллизии) должны использовать переменную из структуры Level, а не макрос.

### 2. Система анимаций (Тайлы и Спрайты)

В *Bounce Back* анимация — это состояние, зависящее от времени.

- Анимация объектов (Кристаллы): В TileMeta (из tile_table.c) нужно добавить поля num_frames и animation_speed. Функция level_render вместо отрисовки одного ID должна вычислять текущий кадр:
frame_id=base_tile_id+(global_timer/speed)(modnum_frames)
- Анимация игрока (Сплющивание): В структуру Player (в types.h) нужно добавить состояние visual_state (нормальный, сжатый, растянутый). Физика будет менять это состояние при ударе, а рендерер в game.c — выбирать соответствующий кадр из атласа.

### 3. Переход на внешние файлы метаданных

Чтобы не переписывать `tile_table.c` под каждую игру, свойства тайлов должны загружаться из файла (например, `tiles.bin`).

- Движок будет просто «исполнителем»: он читает файл, где написано «тайл №15 имеет 3 кадра анимации и убивает игрока». Это позволит менять поведение игры, не трогая ни одной строчки C-кода.

### 4. Слои отрисовки (Parallax и Backgrounds)

*Bounce Back* визуально богаче оригинала. Универсальному движку понадобится:

- Поддержка нескольких слоев в Level (задний план, основной, передний план).
- Параллакс-скроллинг (смещение заднего слоя с другой скоростью), что легко реализуется в level_render_visible_area путем умножения смещения камеры на коэффициент.

---

### Итоговая оценка сложности перехода

| Задача | Сложность | Что нужно сделать |
| --- | --- | --- |
| Другой размер тайла | Высокая | Переписать physics.c с макросов на переменные и подготовить новые маски. |
| Анимация объектов | Низкая | Добавить global_frame_counter и логику выбора кадра в level.c. |
| Анимация шара | Средняя | Добавить машину состояний (FSM) для спрайта игрока в game.c. |
| Универсальность | Средняя | Вынести TILE_DB из кода во внешний файл. |

Если вы начнете рефакторинг с **инкапсуляции ввода** и **разделения структуры Game**, то добавление анимаций станет простой задачей «навешивания» новых функций на уже чистый каркас. С вашим опытом изучения исходников оригинала, адаптация логики анимаций из Java-кода *Bounce Back* в предложенную структуру `TileMeta` не составит труда.

---

То, что парсеры уровней и ресурсов уже готовы, значительно упрощает задачу на этапе подготовки данных. Однако основная сложность при переходе от тайлового движка к объектному в рамках вашего текущего кода сосредоточена в **Runtime-логике** (обработке каждого кадра).

Поскольку у вас уже есть готовые инструменты для чтения объектных данных, вот технический разбор того, что именно придется переписать в коде для перехода на рельсы «Symbian-версии».

---

### 1. Изменение алгоритма поиска коллизий (Модуль physics.c)

Это самый критический узел. Сейчас ваша физика работает по принципу «прямого доступа» (O(1)):

- Функция collisionDetection берет координаты игрока, делит их на 12 (TILE_SIZE) и мгновенно получает индекс нужного тайла в массиве.

**Что изменится:**

- Отказ от деления: В объектном движке вы больше не можете вычислить индекс объекта по его координатам. Вам придется итерироваться по списку объектов.
- Проблема производительности: Если в списке 200 объектов, проверка каждого из них 4 раза за кадр (при MAX_PHYSICS_STEPS_PER_FRAME = 4) создаст нагрузку.
- Решение: Вам нужно будет внедрить Spatial Partitioning (пространственное хеширование). Вы разбиваете уровень на «виртуальные корзины» (например, 64x64 пикселя) и при загрузке регистрируете объекты в тех корзинах, которые они пересекают. Тогда физика будет проверять только те объекты, которые находятся в текущей корзине мяча.

---

### 2. Математика Pixel-Perfect коллизий

В текущем коде маски коллизий (`SMALL_BALL_DATA`, `TRI_TILE_DATA`) жестко привязаны к сетке 12x12.

**Что изменится:**

- Выравнивание масок: Сейчас маска тайла всегда начинается в координатах, кратных 12. В объектном движке объект может находиться в координатах (x: 105, y: 213).
- Новая логика: Функции squareCollide и triangleCollide должны будут вычислять относительный сдвиг (bit-shift) масок относительно друг друга на основе их произвольных координат. Это потребует переписывания логики наложения битовых масок, так как они больше не будут идеально «стыковаться» по границам тайлов.

---

### 3. Рендеринг и сортировка (Модуль level.c)

Сейчас функция `level_render_visible_area` просто рисует сетку в пределах экрана.

**Что изменится:**

- Z-Order (Слои): В объектном движке объекты могут перекрывать друг друга. Вам придется добавить в структуру объекта поле z_index и сортировать список объектов перед отрисовкой (или использовать несколько списков для разных слоев).
- Frustum Culling: Вместо двух циклов for по x и y, вы будете проходить по списку объектов и проверять, попадает ли прямоугольник объекта (Bounding Box) в текущий обзор камеры.

---

### 4. Управление памятью (types.h и level.c)

Сейчас карта — это фиксированный массив.

**Что изменится:**

- Динамические списки: Вам придется использовать malloc для создания массива структур объектов после того, как парсер определит их количество в файле.
- Управление энтити: Если в Symbian-версии объекты могут создаваться или удаляться (например, исчезающие блоки или летящие враги), вам понадобится менеджер памяти для объектов, чтобы избежать фрагментации на PSP.

---

### Итоговый вердикт по сложности

С учетом того, что **парсер готов**, сложность переделки кода оценивается как **выше средней**, но вполне выполнимая:

1. Интерфейс отрисовки (graphics.c / png.c): Менять не нужно. Функции рисования спрайтов по координатам останутся прежними.
2. Ядро физики (physics.c): Потребует полной замены функции testTile на testObject. Вместо обращения к g_level.map[y][x] вы будете вызывать поиск по вашему новому списку объектов.
3. Локализация и звук: Изменений не требуют.

**Главный совет:** Не выбрасывайте текущий код. Используйте его как «проверочный». Сначала добейтесь того, чтобы ваш новый объектный движок рисовал ту же самую картинку, что и тайловый, и только потом переносите логику коллизий.


Да, это именно так. В профессиональной разработке игр этот процесс называется **Asset Pipeline** (конвейер обработки ресурсов). Вы создаете «исходный» файл в удобном для человека формате, а специальный скрипт превращает его в «бинарный» файл, который игра может прочитать мгновенно.

Ниже приведено описание того, как это работает и почему это необходимо для вашего проекта на PSP.

---

### Почему нельзя просто читать TXT или JSON на PSP?

1. Скорость загрузки: Парсинг текста (поиск скобок, кавычек, запятых) требует много времени процессора. Бинарный файл — это готовый слепок памяти. Вы читаете его одной командой fread прямо в массив структур.
2. Экономия памяти: Текстовый файл весит больше. На PSP, где оперативная память ограничена, бинарный формат экономит каждый байт.
3. Безопасность: В бинарном формате сложнее случайно допустить синтаксическую ошибку, которая приведет к «вылету» игры при загрузке.

---

### Как выглядит процесс (Workflow)

Для реализации этой системы вам понадобятся три компонента:

1. Источник (Source): Файл в формате JSON, YAML или даже CSV (таблица). Вы заполняете его в обычном текстовом редакторе.Пример содержимого: «ID: 15, Sprite_ID: 10, Type: COLLECTIBLE, Animation: 3 frames».
2. Скрипт-конвертер (Compiler): Небольшая программа на Python. Она читает ваш текстовый файл, проверяет его на ошибки и упаковывает данные в бинарный вид, строго следуя структуре TileMeta из вашего types.h.
3. Загрузчик в игре (Loader): Код в tile_table.c, который вместо статического массива делает malloc и заполняет его данными из .bin файла.

---

### Как это изменит архитектуру вашего приложения

| Компонент | Текущее состояние | После внедрения конвейера |
| --- | --- | --- |
| Редактирование | Нужно менять .c файл и перекомпилировать игру. | Меняете .json и запускаете скрипт. |
| Добавление уровней | Ограничено макросом MAX_LEVEL. | Движок просто читает столько файлов, сколько есть. |
| Универсальность | Код завязан на одну игру. | Одна и та же программа может стать движком для любой игры, если подложить ей другой .bin. |

---

### Что должен делать скрипт

Скрипт на Python выполняет роль «Gatekeeper» (стража):

- Он проверяет, чтобы индексы спрайтов не выходили за пределы вашего атласа.
- Он может автоматически генерировать заголовочные файлы (.h) с enum, чтобы в коде вы могли обращаться к тайлам по именам, а не по номерам.
- Он выравнивает данные по 4 или 16 байт, что критично для быстрой работы процессора MIPS (PSP).

Такой подход позволит вам за 5 минут адаптировать движок под *Bounce Back*, просто создав новый файл описания тайлов, не меняя ни одной строчки кода в самой игре.


---

Вы абсолютно правы. Это классический путь превращения монолитного кода одной игры в **расширяемый движок**. Ваша идея разделить логику «загрузки» (Parsing) и логику «функционирования» (Runtime) — это именно то, что позволит вам запускать разные игры на одном и том же ядре.

Вот как должна выглядеть эта архитектура, чтобы она была максимально гибкой:

### 1. Единый «Внутренний формат» (Common Interface)

Прежде чем писать ридеры, нужно определить структуры данных, которые **ядро** (модули `level.c`, `physics.c`, `graphics.c`) будет считать «законом».

- LevelData: Массив объектов/тайлов, размеры мира, начальная позиция игрока.
- TileRegistry: Динамический массив свойств (коллизия, индекс в атласе, анимация).
- AssetMap: Список загруженных текстур в VRAM.

---

### 2. Слой «Ридеров» (The Reader Layer)

Вы создаете набор специализированных модулей, задача которых — взять файл в любом формате и заполнить им «Внутренний формат».

| Модуль | Задача | Что делает |
| --- | --- | --- |
| Level Loader | Загрузка мира | Читает .map (Bounce Java) или объектный формат (Bounce Back) и заполняет структуру Level. |
| Resource Provider | Доступ к файлам | Умеет открывать файлы напрямую или доставать «чанки» из ресурсных архивов, как показано в вашем скрипте. |
| Metadata Parser (TF Reader) | Загрузка свойств | Заменяет статичную таблицу TILE_DB. Он читает файл tf, парсит типы коллизий и анимации. |
| Texture Loader | Работа с графикой | Загружает PNG через stb_image, но может брать данные как из файла, так и из буфера в памяти (из «чанка»). |

---

### 3. Пример: Универсальный загрузчик метаданных

Вместо того чтобы жестко прописывать свойства каждого тайла в коде, вы внедряете логику вашего Python-скрипта прямо в C:

C```
// Пример новой функции в tile_table.c
void tile_table_load_from_tf(const char* path) {
    // 1. Открываем файл через Resource Provider
    // 2. Читаем заголовок (количество тайлов, анимаций)
    // 3. Выделяем память (malloc) под динамический TILE_DB
    // 4. В цикле заполняем данные: тип, индекс изображения, флаги
}

```

---

### 4. Почему это выгодно для вас?

- Bounce Java: Вы используете ваш текущий level_load_by_number и стандартные PNG.
- Bounce Back: Вы просто переключаете движок на tf_reader. Система физики physics.c остается той же, но теперь она берет маски коллизий из файла, а не из статических констант.
- Локализация: Вы уже успешно применили этот подход в local.c, где строки грузятся из внешних файлов в зависимости от языка. Теперь нужно сделать то же самое для графики и физики.

### Итог

Да, вам нужно выделить:

1. Level Reader: Для форматов карт.
2. Resource Loader: Для работы с «чанк»-файлами оригинальных ресурсов.
3. TF Parser: Для динамической настройки свойств объектов и тайлов.

